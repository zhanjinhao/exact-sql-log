package cn.addenda.exactsqllog.proxy.jdbc;

import cn.addenda.exactsqllog.common.util.UuidUtils;
import cn.addenda.exactsqllog.proxy.sql.ExecutionQueue;
import cn.addenda.exactsqllog.proxy.writer.SqlWriter;
import cn.addenda.exactsqllog.proxy.system.SystemLogger;
import lombok.Getter;

import java.sql.*;
import java.util.HashMap;
import java.util.Map;

/**
 * @author addenda
 * @since 2024/8/24 17:03
 */
public class EslConnection extends AbstractEslConnection implements Connection, EslIded {

  private final String eslId;

  @Getter
  private String txId;

  private final SystemLogger systemLogger;

  @Getter
  private final ExecutionQueue executionQueue;

  @Getter
  private boolean ifAutoCommit;

  public EslConnection(Connection connection, SystemLogger systemLogger, SqlWriter sqlWriter) throws SQLException {
    super(connection);
    this.systemLogger = systemLogger;
    this.executionQueue = new ExecutionQueue(sqlWriter);
    this.eslId = UuidUtils.generateUuid();
    this.ifAutoCommit = connection.getAutoCommit();
    newTxId();
  }

  public void newTxId() {
    this.txId = UuidUtils.generateUuid();
  }

  @Override
  public void setAutoCommit(boolean autoCommit) throws SQLException {
    connection.setAutoCommit(autoCommit);
    // true -> false: execute的数据都提交完成了
    // false -> true: 提交execute但还未提交的数据
    if (ifAutoCommit != autoCommit) {
      if (autoCommit) {
        executionQueue.propagateCommitted();
      }
    }
    // true -> true
    // false -> false
    else {
      // no-op
    }
    newTxId();
    ifAutoCommit = autoCommit;
  }

  @Override
  public boolean getAutoCommit() throws SQLException {
    ifAutoCommit = connection.getAutoCommit();
    return ifAutoCommit;
  }

  @Override
  public void commit() throws SQLException {
    connection.commit();
    newTxId();
    executionQueue.propagateCommitted();
  }

  @Override
  public void rollback() throws SQLException {
    connection.rollback();
    newTxId();
    executionQueue.propagateRollback();
  }

  @Override
  public void close() throws SQLException {
    connection.close();
    closeEsl();
    // todo 连接池里的connection不会真正被close，所以需要查看各个连接池的代码，保证释放connection的时候能回调closeEsl()
  }

  @Override
  public Statement createStatement() throws SQLException {
    Statement statement = connection.createStatement();
    EslStatement eslStatement = new EslStatement(statement, this);

    addEslStatement(eslStatement);

    return eslStatement;
  }

  @Override
  public Statement createStatement(int resultSetType, int resultSetConcurrency) throws SQLException {
    Statement statement = connection.createStatement(resultSetType, resultSetConcurrency);
    EslStatement eslStatement = new EslStatement(statement, this);

    addEslStatement(eslStatement);

    return eslStatement;
  }

  @Override
  public Statement createStatement(int resultSetType, int resultSetConcurrency, int resultSetHoldability) throws SQLException {
    Statement statement = connection.createStatement(resultSetType, resultSetConcurrency, resultSetHoldability);
    EslStatement eslStatement = new EslStatement(statement, this);

    addEslStatement(eslStatement);

    return eslStatement;
  }

  @Override
  public PreparedStatement prepareStatement(String sql) throws SQLException {
    PreparedStatement ps = connection.prepareStatement(sql);
    EslPreparedStatement eslPreparedStatement = new EslPreparedStatement(ps, this, sql);

    addEslPreparedStatement(eslPreparedStatement);

    return eslPreparedStatement;
  }

  @Override
  public PreparedStatement prepareStatement(String sql, int resultSetType, int resultSetConcurrency) throws SQLException {
    PreparedStatement ps = connection.prepareStatement(sql, resultSetType, resultSetConcurrency);
    EslPreparedStatement eslPreparedStatement = new EslPreparedStatement(ps, this, sql);

    addEslPreparedStatement(eslPreparedStatement);

    return eslPreparedStatement;
  }

  @Override
  public PreparedStatement prepareStatement(String sql, int resultSetType, int resultSetConcurrency, int resultSetHoldability) throws SQLException {
    PreparedStatement ps = connection.prepareStatement(sql, resultSetType, resultSetConcurrency, resultSetHoldability);
    EslPreparedStatement eslPreparedStatement = new EslPreparedStatement(ps, this, sql);

    addEslPreparedStatement(eslPreparedStatement);

    return eslPreparedStatement;
  }

  @Override
  public PreparedStatement prepareStatement(String sql, int autoGeneratedKeys) throws SQLException {
    PreparedStatement ps = connection.prepareStatement(sql, autoGeneratedKeys);
    EslPreparedStatement eslPreparedStatement = new EslPreparedStatement(ps, this, sql);

    addEslPreparedStatement(eslPreparedStatement);

    return eslPreparedStatement;
  }

  @Override
  public PreparedStatement prepareStatement(String sql, int[] columnIndexes) throws SQLException {
    PreparedStatement ps = connection.prepareStatement(sql, columnIndexes);
    EslPreparedStatement eslPreparedStatement = new EslPreparedStatement(ps, this, sql);

    addEslPreparedStatement(eslPreparedStatement);

    return eslPreparedStatement;
  }

  @Override
  public PreparedStatement prepareStatement(String sql, String[] columnNames) throws SQLException {
    PreparedStatement ps = connection.prepareStatement(sql, columnNames);
    EslPreparedStatement eslPreparedStatement = new EslPreparedStatement(ps, this, sql);

    addEslPreparedStatement(eslPreparedStatement);

    return eslPreparedStatement;
  }

  // --------------------------------------------------------------
  //  不支持存储过程，因为存储过程隐藏了具体的sql，无法解析出受影响的表和字段。
  // --------------------------------------------------------------

  @Override
  public CallableStatement prepareCall(String sql) throws SQLException {
    // todo 暂不支持存储过程
    return connection.prepareCall(sql);
  }

  @Override
  public CallableStatement prepareCall(String sql, int resultSetType, int resultSetConcurrency) throws SQLException {
    // todo 暂不支持存储过程
    return connection.prepareCall(sql, resultSetType, resultSetConcurrency);
  }

  @Override
  public CallableStatement prepareCall(String sql, int resultSetType, int resultSetConcurrency, int resultSetHoldability) throws SQLException {
    // todo 暂不支持存储过程
    return connection.prepareCall(sql, resultSetType, resultSetConcurrency, resultSetHoldability);
  }

  @Override
  public Savepoint setSavepoint() throws SQLException {
    // todo 不知道怎么处理
    return connection.setSavepoint();
  }

  @Override
  public Savepoint setSavepoint(String name) throws SQLException {
    // todo 不知道怎么处理
    return connection.setSavepoint(name);
  }

  @Override
  public void rollback(Savepoint savepoint) throws SQLException {
    // todo 不知道怎么处理
    connection.rollback(savepoint);
  }

  @Override
  public void releaseSavepoint(Savepoint savepoint) throws SQLException {
    // todo 不知道怎么处理
    connection.releaseSavepoint(savepoint);
  }

  // -----------
  //   EslIded
  // -----------

  @Override
  public String getEslId() {
    return eslId;
  }

  // ------------------------------------------------
  //   EslPreparedStatement&EslStatement Management
  // ------------------------------------------------

  @Override
  public void closeEsl() throws SQLException {
    synchronized (executionQueue) {
      // 按照先申请资源后释放的步骤，在Connection关闭的时候，其创造的Statement和PreparedStatement一定都关闭完成了。
      // 但是，为了在遇到异常步骤时尽可能减少内存泄漏，在close这里还是释放一下
      closeAllEslStatement();
      closeAllEslPreparedStatement();
    }
  }

  private final Map<String, EslPreparedStatement> eslPreparedStatementMap = new HashMap<>();

  private void addEslPreparedStatement(EslPreparedStatement eslPreparedStatement) {
    synchronized (executionQueue) {
      eslPreparedStatementMap.put(eslPreparedStatement.getEslId(), eslPreparedStatement);
    }
  }

  public void removeEslStatement(EslPreparedStatement eslPreparedStatement) {
    synchronized (executionQueue) {
      eslPreparedStatementMap.remove(eslPreparedStatement.getEslId());
    }
  }

  private void closeAllEslPreparedStatement() throws SQLException {
    synchronized (executionQueue) {
      for (EslPreparedStatement eslPreparedStatement : eslPreparedStatementMap.values()) {
        try {
          // close()方法执行的时候，会执行closeEsl()方法
          if (!eslPreparedStatement.isClosed()) {
            eslPreparedStatement.closeEsl();
          }
        } catch (SQLException e) {
          systemLogger.error("exception occurred when EslPreparedStatement close, {}.", eslPreparedStatement, e);
          throw e;
        }
      }
    }
  }

  private final Map<String, EslStatement> eslStatementMap = new HashMap<>();

  private void addEslStatement(EslStatement eslStatement) {
    synchronized (executionQueue) {
      eslStatementMap.put(eslStatement.getEslId(), eslStatement);
    }
  }

  public void removeEslStatement(EslStatement eslStatement) {
    synchronized (executionQueue) {
      eslStatementMap.remove(eslStatement.getEslId());
    }
  }

  private void closeAllEslStatement() throws SQLException {
    synchronized (executionQueue) {
      for (EslStatement eslStatement : eslStatementMap.values()) {
        try {
          // close()方法执行的时候，会执行closeEsl()方法
          if (!eslStatement.isClosed()) {
            eslStatement.closeEsl();
          }
        } catch (SQLException e) {
          systemLogger.error("exception occurred when EslStatement close, {}.", eslStatement, e);
          throw e;
        }
      }
    }
  }

  // -----------
  //   基础方法
  // -----------

  @Override
  public String toString() {
    return "EslConnection{" +
            "eslId='" + eslId + '\'' +
            "} " + super.toString();
  }

}
